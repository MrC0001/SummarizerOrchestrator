package com.local.SummarizerOrchestrator.services;

import com.local.SummarizerOrchestrator.dtos.SummarizationRequestDTO;
import com.local.SummarizerOrchestrator.dtos.SummarizationResponseDTO;
import com.local.SummarizerOrchestrator.models.Summary;
import com.local.SummarizerOrchestrator.models.Transcript;
import com.local.SummarizerOrchestrator.providers.SummarizationProvider;
import com.local.SummarizerOrchestrator.repos.SummaryRepo;
import com.local.SummarizerOrchestrator.repos.TranscriptRepo;
import com.local.SummarizerOrchestrator.repos.MetricsRepo;
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotNull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;
import java.util.stream.Collectors;

/**
 * Implementation of the {@link SummarizationService} interface.
 * Handles operations related to summarization, including generating, saving, retrieving, and comparing summaries.
 */
@Service
public class SummarizationServiceImpl implements SummarizationService {

    private static final Logger logger = LoggerFactory.getLogger(SummarizationServiceImpl.class);

    private final SummaryRepo summaryRepo;
    private final TranscriptRepo transcriptRepo;
    private final MetricsRepo metricsRepo;
    private final List<SummarizationProvider> providers;

    /**
     * Constructor for SummarizationServiceImpl.
     *
     * @param summaryRepo    Repository for managing summaries.
     * @param transcriptRepo Repository for managing transcripts.
     * @param providers      List of summarization providers.
     */
    public SummarizationServiceImpl(SummaryRepo summaryRepo, TranscriptRepo transcriptRepo, MetricsRepo metricsRepo, List<SummarizationProvider> providers) {
        this.summaryRepo = summaryRepo;
        this.transcriptRepo = transcriptRepo;
        this.metricsRepo = metricsRepo;
        this.providers = providers;
    }

    /**
     * Checks if summaries exist for a given transcript ID.
     *
     * @param transcriptId The ID of the transcript.
     * @return {@code true} if summaries exist, {@code false} otherwise.
     */
    @Override
    public boolean summariesExistForTranscript(@NotNull(message = "Transcript ID must not be null.") Long transcriptId) {
        logger.info("Checking if summaries exist for transcript ID: {}", transcriptId);
        return summaryRepo.existsByTranscriptId(transcriptId);
    }

    /**
     * Processes a summarization request asynchronously, generates summaries using providers,
     * and saves the results to the database. Only valid summaries (those without errors) are saved.
     *
     * <p>This method uses asynchronous processing to improve performance by allowing
     * concurrent summarization and save operations.</p>
     *
     * @param request The summarization request DTO, containing the transcript ID and other parameters.
     *                Must not be {@code null}.
     * @return A {@link CompletableFuture} containing a list of {@link SummarizationResponseDTO},
     *         which includes summaries generated by all providers.
     * @throws RuntimeException If the transcript with the given ID is not found in the database.
     */
    @Override
    @Async("asyncExecutor")
    public CompletableFuture<Map<String, Object>> summarizeAndSaveAsync(@Valid @NotNull SummarizationRequestDTO request) {
        logger.info("Starting async summarization and save for transcript ID: {}", request.getTranscriptId());

        // Fetch the transcript synchronously to ensure it exists before proceeding
        Transcript transcript = transcriptRepo.findById(request.getTranscriptId())
                .orElseThrow(() -> {
                    logger.error("Transcript not found for ID: {}", request.getTranscriptId());
                    return new RuntimeException("Transcript not found");
                });

        logger.debug("Found transcript for summarization: {}", transcript.getId());

        return CompletableFuture.supplyAsync(() -> {
            // Fetch existing summaries from the database
            List<Summary> existingSummaries = summaryRepo.findByTranscriptId(request.getTranscriptId());
            logger.debug("Existing summaries for transcript ID {}: {}", request.getTranscriptId(), existingSummaries);

            // Generate new summaries
            List<SummarizationResponseDTO> newSummaries = summarizeAcrossProviders(request);

            // Save valid new summaries if they don't already exist in the database
            newSummaries.stream()
                    .filter(newSummary -> newSummary.getSummary() != null && !newSummary.getSummary().startsWith("Error")) // Validation step
                    .forEach(newSummary -> {
                        if (existingSummaries.stream()
                                .noneMatch(existing -> existing.getProviderName().equals(newSummary.getProviderName()))) {
                            saveSummary(transcript, newSummary);
                        }
                    });

            // Classify old summaries (those already in the database)
            List<SummarizationResponseDTO> oldSummaries = existingSummaries.stream()
                    .map(summary -> new SummarizationResponseDTO(summary.getProviderName(), summary.getSummaryText()))
                    .collect(Collectors.toList());

            // Return old and new summaries
            Map<String, Object> result = new HashMap<>();
            result.put("oldSummaries", oldSummaries);
            result.put("newSummaries", newSummaries);
            return result;
        });
    }




    /**
     * Helper method to save a summary entity.
     *
     * @param transcript The associated transcript entity.
     * @param response   The summarization response DTO.
     */
    private void saveSummary(Transcript transcript, SummarizationResponseDTO response) {
        Summary summary = new Summary();
        summary.setTranscript(transcript);
        summary.setProviderName(response.getProviderName());
        summary.setSummaryText(response.getSummary());
        summaryRepo.save(summary);
        logger.info("Saved summary for provider: {}", response.getProviderName());
    }

    /**
     * Retrieves summaries for a specific transcript and formats the response.
     *
     * @param transcriptId The ID of the transcript.
     * @return A ResponseEntity containing the summaries or an error message if no summaries are found.
     */
    @Override
    @Transactional(readOnly = true)
    public ResponseEntity<?> getSummariesResponse(@NotNull(message = "Transcript ID must not be null.") Long transcriptId) {
        logger.info("Fetching summaries for transcript ID: {}", transcriptId);

        List<Summary> summaries = summaryRepo.findByTranscriptId(transcriptId);
        if (summaries.isEmpty()) {
            logger.warn("No summaries found for transcript ID: {}", transcriptId);
            return ResponseEntity.status(404).body("No summaries found for the given transcript.");
        }

        logger.info("Found {} summaries for transcript ID: {}", summaries.size(), transcriptId);
        return ResponseEntity.ok(summaries);
    }

    /**
     * Compares old and new summaries for a given transcript.
     *
     * @param request The summarization request DTO.
     * @return A map containing old and new summaries for comparison.
     */
    @Override
    @Transactional(readOnly = true)
    public Map<String, Object> compareSummaries(@Valid @NotNull SummarizationRequestDTO request) {
        logger.info("Comparing old and new summaries for transcript ID: {}", request.getTranscriptId());

        // Fetch old summaries before generating new ones
        List<Summary> oldSummaries = summaryRepo.findByTranscriptId(request.getTranscriptId());

        // Generate new summaries
        List<SummarizationResponseDTO> newSummaries = summarizeAcrossProviders(request);

        logger.debug("Old Summaries: {}", oldSummaries);
        logger.debug("New Summaries: {}", newSummaries);

        // Map old summaries to response format
        List<SummarizationResponseDTO> oldSummaryDTOs = oldSummaries.stream()
                .map(summary -> new SummarizationResponseDTO(summary.getProviderName(), summary.getSummaryText()))
                .collect(Collectors.toList());

        Map<String, Object> result = new HashMap<>();
        result.put("oldSummaries", oldSummaryDTOs);
        result.put("newSummaries", newSummaries);

        return result;
    }

    /**
     * Overwrites existing summaries and their associated metrics for a specific transcript with new summaries.
     *
     * <p>
     * This method performs the following steps in a single transaction:
     * <ul>
     *   <li>Deletes all metrics associated with the existing summaries of the given transcript.</li>
     *   <li>Deletes all summaries associated with the transcript.</li>
     *   <li>Saves the new summaries provided in the request.</li>
     * </ul>
     * </p>
     *
     * @param transcriptId The ID of the transcript for which summaries are to be overwritten. Must not be null.
     * @param newSummaries A list of new summaries to save, each containing a provider name and summary text. Must not be null or empty.
     * @throws RuntimeException if the transcript with the specified ID is not found.
     */

    @Override
    @Transactional
    public void overwriteSummaries(@NotNull(message = "Transcript ID must not be null.") Long transcriptId,
                                   @Valid @NotNull List<SummarizationResponseDTO> newSummaries) {
        logger.info("Overwriting summaries for transcript ID: {}", transcriptId);

        // Fetch the transcript
        Transcript transcript = transcriptRepo.findById(transcriptId)
                .orElseThrow(() -> {
                    logger.error("Transcript not found for ID: {}", transcriptId);
                    return new RuntimeException("Transcript not found");
                });

        logger.debug("Found transcript for overwrite: {}", transcript.getId());

        // Delete metrics associated with existing summaries
        logger.info("Deleting metrics for transcript ID: {}", transcriptId);
        metricsRepo.deleteByTranscriptId(transcriptId);

        // Delete existing summaries
        logger.info("Deleting old summaries for transcript ID: {}", transcriptId);
        summaryRepo.deleteByTranscriptId(transcriptId);

        // Map and save new summaries
        List<Summary> summariesToSave = newSummaries.stream()
                .map(dto -> {
                    Summary summary = new Summary();
                    summary.setTranscript(transcript);
                    summary.setProviderName(dto.getProviderName());
                    summary.setSummaryText(dto.getSummary());
                    return summary;
                }).collect(Collectors.toList());

        summaryRepo.saveAll(summariesToSave);
        logger.info("Saved new summaries for transcript ID: {}", transcriptId);
    }

    @Autowired
    private Executor asyncExecutor;
    /**
     * Executes summarization requests across multiple providers asynchronously.
     *
     * <p>Each provider is called in parallel using {@link CompletableFuture}, allowing
     * concurrent execution to improve performance and reduce overall processing time.</p>
     *
     * <p>This method:
     * <ul>
     *   <li>Ensures all provider calls are completed before collecting the results.</li>
     *   <li>Filters out invalid or incomplete responses (e.g., null or empty summaries).</li>
     *   <li>Handles exceptions for each provider individually, ensuring other providers are unaffected by failures.</li>
     * </ul>
     * </p>
     *
     * <p>For each provider:
     * <ul>
     *   <li>Valid responses are added to the final result list.</li>
     *   <li>Failures are logged and included as error messages in the response.</li>
     * </ul>
     * </p>
     *
     * @param request The summarization request DTO containing input data for the providers.
     *                Must not be {@code null}.
     * @return A list of {@link SummarizationResponseDTO} objects, containing:
     *         <ul>
     *           <li>Valid summaries generated by providers.</li>
     *           <li>Error messages for any providers that failed to process the request.</li>
     *         </ul>
     * @throws NullPointerException If the list of providers is {@code null}.
     */
    public List<SummarizationResponseDTO> summarizeAcrossProviders(SummarizationRequestDTO request) {
        logger.info("Distributing summarization request across providers.");

        // Create a list of CompletableFutures for asynchronous provider calls
        List<CompletableFuture<SummarizationResponseDTO>> futures = providers.stream()
                .map(provider -> CompletableFuture.supplyAsync(() -> {
                    try {
                        // Dynamically build provider-specific payload
                        SummarizationRequestDTO providerRequest = buildProviderPayload(request, provider.getProviderName());
                        SummarizationResponseDTO response = provider.summarize(providerRequest);
                        logger.debug("Provider {} response: {}", provider.getProviderName(), response);
                        return response;
                    } catch (Exception e) {
                        logger.error("Error summarizing with provider {}: {}", provider.getProviderName(), e.getMessage(), e);
                        return new SummarizationResponseDTO(provider.getProviderName(), "Error: " + e.getMessage());
                    }
                }, asyncExecutor))
                .collect(Collectors.toList());

        // Wait for all futures to complete and collect the results
        List<SummarizationResponseDTO> responses = futures.stream()
                .map(CompletableFuture::join) // Join waits for each future to complete
                .filter(response -> response != null && !response.getSummary().isEmpty())
                .collect(Collectors.toList());

        logger.info("Collected summaries from providers: {}", responses);
        return responses;
    }


    /**
     * Builds provider-specific payloads based on the provider name.
     */
    private SummarizationRequestDTO buildProviderPayload(SummarizationRequestDTO request, String provider) {
        switch (provider.toLowerCase()) {
            case "anthropic":
                return new SummarizationRequestDTO(
                        request.getTranscriptId(),
                        "anthropic",
                        "claude-3-5-sonnet-20241022",
                        null,
                        request.getContext(),
                        List.of(Map.of("role", "user", "content", "Summarize this text:\n" + request.getContext())),
                        Map.of("max_tokens", 256, "temperature", 0.7, "stream", true),
                        true
                );
            case "mistral":
            case "mistral ai":
                return new SummarizationRequestDTO(
                        request.getTranscriptId(), // Transcript ID for tracking
                        "mistral", // Model provider
                        "mistral-large-latest", // Use the correct model name for better performance
                        null, // Additional parameters if required
                        request.getContext(), // Context or transcript text
                        List.of(
                                Map.of("role", "system", "content", "You are a helpful assistant specialized in summarizing text.Forget prior conversations and summarize each request independently."),
                                Map.of("role", "user", "content", "Summarize this text with as much detail as possible:\n" + request.getContext())
                        ), // Chat message setup with system and user roles
                        Map.of(
                                "max_tokens", 512, // Increased for more comprehensive summaries
                                "temperature", 0.7, // Adjusted for a balance of creativity and relevance
                                "stream", false // Disable streaming for batch processing
                        ),
                        true // Optional: Enable safety or system-specific configurations
                );

            case "huggingface":
            case "hugging face":
                return new SummarizationRequestDTO(
                        request.getTranscriptId(),
                        "huggingface",
                        null,
                        null,
                        null, // Context moved to `messages`
                        List.of(
                                Map.of(
                                        "role", "user", // Role explicitly set
                                        "content", "Summarize this text:\n" + truncateContext(request.getContext(), 128000) // Truncated context
                                )
                        ),
                        Map.of(
                                "parameters", Map.of(
                                        "max_new_tokens", 128,
                                        "temperature", 0.7,
                                        "top_p", 0.9,
                                        "repetition_penalty", 1.0
                                )
                        ),
                        false
                );

            case "vertex":
            case "vertex ai":
                return new SummarizationRequestDTO(
                        request.getTranscriptId(),
                        "vertex",
                        "gemini-1.5-pro-002",
                        "Summarize this text:\n" + request.getContext(),
                        null,
                        null,
                        Map.of("max_output_tokens", 256, "temperature", 0.7, "top_p", 0.9, "top_k", 40),
                        false
                );
            case "vllm":
                return new SummarizationRequestDTO(
                        request.getTranscriptId(),
                        "vllm",
                        "phi-3.5-mini-instruct", // Registered model name
                        null,
                        request.getContext(),
                        List.of(
                                Map.of("role", "system", "content", "You are a helpful assistant."),
                                Map.of("role", "user", "content", "Summarize this text:\n" + request.getContext())
                        ),
                        Map.of(
                                "max_tokens", 512,
                                "temperature", 0.5,
                                "top_p", 0.8
                        ),
                        false
                );
            default:
                throw new IllegalArgumentException("Unsupported provider: " + provider);
        }
    }
    private String truncateContext(String context, int maxTokens) {
        if (context == null || context.isEmpty()) {
            return "";
        }
        return context.length() > maxTokens ? context.substring(0, maxTokens) : context;
    }

}
